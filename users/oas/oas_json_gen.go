// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"math/bits"
	"net/url"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes BirthString as json.
func (s BirthString) Encode(e *jx.Encoder) {
	unwrapped := time.Time(s)

	json.EncodeDate(e, unwrapped)
}

// Decode decodes BirthString from json.
func (s *BirthString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BirthString to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDate(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BirthString(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BirthString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BirthString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		s.Login.Encode(e)
	}
	{
		e.FieldStart("password")
		s.Password.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		if s.Root.Set {
			e.FieldStart("root")
			s.Root.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateUserRequest = [4]string{
	0: "login",
	1: "password",
	2: "email",
	3: "root",
}

// Decode decodes CreateUserRequest from json.
func (s *CreateUserRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "root":
			if err := func() error {
				s.Root.Reset()
				if err := s.Root.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"root\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserRequest) {
					name = jsonFieldsNameOfCreateUserRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DateString as json.
func (s DateString) Encode(e *jx.Encoder) {
	unwrapped := time.Time(s)

	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes DateString from json.
func (s *DateString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DateString to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DateString(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DateString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DateString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EmailString as json.
func (s EmailString) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes EmailString from json.
func (s *EmailString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmailString to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EmailString(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EmailString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EmailString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendAliasString as json.
func (s FriendAliasString) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes FriendAliasString from json.
func (s *FriendAliasString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendAliasString to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FriendAliasString(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FriendAliasString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendAliasString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendHiddenFlag as json.
func (s FriendHiddenFlag) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes FriendHiddenFlag from json.
func (s *FriendHiddenFlag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendHiddenFlag to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FriendHiddenFlag(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FriendHiddenFlag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendHiddenFlag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendList as json.
func (s FriendList) Encode(e *jx.Encoder) {
	unwrapped := []FriendObject(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes FriendList from json.
func (s *FriendList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendList to nil")
	}
	var unwrapped []FriendObject
	if err := func() error {
		unwrapped = make([]FriendObject, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem FriendObject
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FriendList(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FriendList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FriendModify) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FriendModify) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("friend_id")
		s.FriendID.Encode(e)
	}
	{
		if s.Alias.Set {
			e.FieldStart("alias")
			s.Alias.Encode(e)
		}
	}
	{
		if s.Subscibed.Set {
			e.FieldStart("subscibed")
			s.Subscibed.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.Delete.Set {
			e.FieldStart("delete")
			s.Delete.Encode(e)
		}
	}
}

var jsonFieldsNameOfFriendModify = [5]string{
	0: "friend_id",
	1: "alias",
	2: "subscibed",
	3: "hidden",
	4: "delete",
}

// Decode decodes FriendModify from json.
func (s *FriendModify) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendModify to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "friend_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.FriendID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friend_id\"")
			}
		case "alias":
			if err := func() error {
				s.Alias.Reset()
				if err := s.Alias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alias\"")
			}
		case "subscibed":
			if err := func() error {
				s.Subscibed.Reset()
				if err := s.Subscibed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscibed\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "delete":
			if err := func() error {
				s.Delete.Reset()
				if err := s.Delete.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FriendModify")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFriendModify) {
					name = jsonFieldsNameOfFriendModify[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FriendModify) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendModify) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FriendObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FriendObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("friend_id")
		s.FriendID.Encode(e)
	}
	{
		if s.Alias.Set {
			e.FieldStart("alias")
			s.Alias.Encode(e)
		}
	}
	{
		if s.Subscibed.Set {
			e.FieldStart("subscibed")
			s.Subscibed.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.Paired.Set {
			e.FieldStart("paired")
			s.Paired.Encode(e)
		}
	}
	{
		if s.FriendedAt.Set {
			e.FieldStart("friendedAt")
			s.FriendedAt.Encode(e)
		}
	}
	{
		if s.LastModify.Set {
			e.FieldStart("lastModify")
			s.LastModify.Encode(e)
		}
	}
}

var jsonFieldsNameOfFriendObject = [7]string{
	0: "friend_id",
	1: "alias",
	2: "subscibed",
	3: "hidden",
	4: "paired",
	5: "friendedAt",
	6: "lastModify",
}

// Decode decodes FriendObject from json.
func (s *FriendObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "friend_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.FriendID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friend_id\"")
			}
		case "alias":
			if err := func() error {
				s.Alias.Reset()
				if err := s.Alias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alias\"")
			}
		case "subscibed":
			if err := func() error {
				s.Subscibed.Reset()
				if err := s.Subscibed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscibed\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "paired":
			if err := func() error {
				s.Paired.Reset()
				if err := s.Paired.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paired\"")
			}
		case "friendedAt":
			if err := func() error {
				s.FriendedAt.Reset()
				if err := s.FriendedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friendedAt\"")
			}
		case "lastModify":
			if err := func() error {
				s.LastModify.Reset()
				if err := s.LastModify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModify\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FriendObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFriendObject) {
					name = jsonFieldsNameOfFriendObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FriendObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendPairedFlag as json.
func (s FriendPairedFlag) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes FriendPairedFlag from json.
func (s *FriendPairedFlag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendPairedFlag to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FriendPairedFlag(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FriendPairedFlag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendPairedFlag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendSubscribedFlag as json.
func (s FriendSubscribedFlag) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes FriendSubscribedFlag from json.
func (s *FriendSubscribedFlag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendSubscribedFlag to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FriendSubscribedFlag(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FriendSubscribedFlag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendSubscribedFlag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FriendsUserIDPostOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FriendsUserIDPostOK) encodeFields(e *jx.Encoder) {
	{
		if s.Friend.Set {
			e.FieldStart("friend")
			s.Friend.Encode(e)
		}
	}
}

var jsonFieldsNameOfFriendsUserIDPostOK = [1]string{
	0: "friend",
}

// Decode decodes FriendsUserIDPostOK from json.
func (s *FriendsUserIDPostOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendsUserIDPostOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "friend":
			if err := func() error {
				s.Friend.Reset()
				if err := s.Friend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FriendsUserIDPostOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FriendsUserIDPostOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendsUserIDPostOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JwtToken as json.
func (s JwtToken) Encode(e *jx.Encoder) {
	unwrapped := []byte(s)

	e.Base64(unwrapped)
}

// Decode decodes JwtToken from json.
func (s *JwtToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JwtToken to nil")
	}
	var unwrapped []byte
	if err := func() error {
		v, err := d.Base64()
		unwrapped = []byte(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JwtToken(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JwtToken) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JwtToken) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LinkString as json.
func (s LinkString) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)

	json.EncodeURI(e, unwrapped)
}

// Decode decodes LinkString from json.
func (s *LinkString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinkString to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LinkString(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LinkString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinkString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginPostOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginPostOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		s.Token.Encode(e)
	}
	{
		e.FieldStart("user_id")
		s.UserID.Encode(e)
	}
}

var jsonFieldsNameOfLoginPostOK = [2]string{
	0: "token",
	1: "user_id",
}

// Decode decodes LoginPostOK from json.
func (s *LoginPostOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginPostOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Token.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginPostOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginPostOK) {
					name = jsonFieldsNameOfLoginPostOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginPostOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginPostOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoginString as json.
func (s LoginString) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes LoginString from json.
func (s *LoginString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginString to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LoginString(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LoginString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginUserRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginUserRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		s.Login.Encode(e)
	}
	{
		e.FieldStart("password")
		s.Password.Encode(e)
	}
}

var jsonFieldsNameOfLoginUserRequest = [2]string{
	0: "login",
	1: "password",
}

// Decode decodes LoginUserRequest from json.
func (s *LoginUserRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginUserRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginUserRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginUserRequest) {
					name = jsonFieldsNameOfLoginUserRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginUserRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginUserRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NameString as json.
func (s NameString) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes NameString from json.
func (s *NameString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NameString to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = NameString(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NameString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NameString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BirthString as json.
func (o OptBirthString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BirthString from json.
func (o *OptBirthString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBirthString to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBirthString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBirthString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DateString as json.
func (o OptDateString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DateString from json.
func (o *OptDateString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateString to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EmailString as json.
func (o OptEmailString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EmailString from json.
func (o *OptEmailString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEmailString to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEmailString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEmailString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendAliasString as json.
func (o OptFriendAliasString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FriendAliasString from json.
func (o *OptFriendAliasString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFriendAliasString to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFriendAliasString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFriendAliasString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendHiddenFlag as json.
func (o OptFriendHiddenFlag) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FriendHiddenFlag from json.
func (o *OptFriendHiddenFlag) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFriendHiddenFlag to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFriendHiddenFlag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFriendHiddenFlag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendObject as json.
func (o OptFriendObject) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FriendObject from json.
func (o *OptFriendObject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFriendObject to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFriendObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFriendObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendPairedFlag as json.
func (o OptFriendPairedFlag) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FriendPairedFlag from json.
func (o *OptFriendPairedFlag) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFriendPairedFlag to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFriendPairedFlag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFriendPairedFlag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendSubscribedFlag as json.
func (o OptFriendSubscribedFlag) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FriendSubscribedFlag from json.
func (o *OptFriendSubscribedFlag) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFriendSubscribedFlag to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFriendSubscribedFlag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFriendSubscribedFlag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LinkString as json.
func (o OptLinkString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LinkString from json.
func (o *OptLinkString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLinkString to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLinkString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLinkString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NameString as json.
func (o OptNameString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NameString from json.
func (o *OptNameString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNameString to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNameString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNameString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RootFlag as json.
func (o OptRootFlag) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RootFlag from json.
func (o *OptRootFlag) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRootFlag to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRootFlag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRootFlag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TelephoneString as json.
func (o OptTelephoneString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TelephoneString from json.
func (o *OptTelephoneString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTelephoneString to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTelephoneString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTelephoneString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PasswordString as json.
func (s PasswordString) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes PasswordString from json.
func (s *PasswordString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasswordString to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PasswordString(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PasswordString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasswordString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProfileInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProfileInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		s.Login.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("root")
		s.Root.Encode(e)
	}
	{
		if s.FirstName.Set {
			e.FieldStart("firstName")
			s.FirstName.Encode(e)
		}
	}
	{
		if s.LastName.Set {
			e.FieldStart("lastName")
			s.LastName.Encode(e)
		}
	}
	{
		if s.ImageLink.Set {
			e.FieldStart("imageLink")
			s.ImageLink.Encode(e)
		}
	}
	{
		if s.BirthDate.Set {
			e.FieldStart("birthDate")
			s.BirthDate.Encode(e)
		}
	}
	{
		if s.Telephone.Set {
			e.FieldStart("telephone")
			s.Telephone.Encode(e)
		}
	}
	{
		if s.RegDate.Set {
			e.FieldStart("regDate")
			s.RegDate.Encode(e)
		}
	}
	{
		if s.LastModify.Set {
			e.FieldStart("lastModify")
			s.LastModify.Encode(e)
		}
	}
}

var jsonFieldsNameOfProfileInfo = [10]string{
	0: "login",
	1: "email",
	2: "root",
	3: "firstName",
	4: "lastName",
	5: "imageLink",
	6: "birthDate",
	7: "telephone",
	8: "regDate",
	9: "lastModify",
}

// Decode decodes ProfileInfo from json.
func (s *ProfileInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProfileInfo to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "root":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Root.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"root\"")
			}
		case "firstName":
			if err := func() error {
				s.FirstName.Reset()
				if err := s.FirstName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstName\"")
			}
		case "lastName":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastName\"")
			}
		case "imageLink":
			if err := func() error {
				s.ImageLink.Reset()
				if err := s.ImageLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageLink\"")
			}
		case "birthDate":
			if err := func() error {
				s.BirthDate.Reset()
				if err := s.BirthDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthDate\"")
			}
		case "telephone":
			if err := func() error {
				s.Telephone.Reset()
				if err := s.Telephone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telephone\"")
			}
		case "regDate":
			if err := func() error {
				s.RegDate.Reset()
				if err := s.RegDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regDate\"")
			}
		case "lastModify":
			if err := func() error {
				s.LastModify.Reset()
				if err := s.LastModify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModify\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProfileInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProfileInfo) {
					name = jsonFieldsNameOfProfileInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProfileInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProfileInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProfileUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProfileUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.FirstName.Set {
			e.FieldStart("firstName")
			s.FirstName.Encode(e)
		}
	}
	{
		if s.LastName.Set {
			e.FieldStart("lastName")
			s.LastName.Encode(e)
		}
	}
	{
		if s.ImageLink.Set {
			e.FieldStart("imageLink")
			s.ImageLink.Encode(e)
		}
	}
	{
		if s.BirthDate.Set {
			e.FieldStart("birthDate")
			s.BirthDate.Encode(e)
		}
	}
	{
		if s.Telephone.Set {
			e.FieldStart("telephone")
			s.Telephone.Encode(e)
		}
	}
}

var jsonFieldsNameOfProfileUpdate = [6]string{
	0: "email",
	1: "firstName",
	2: "lastName",
	3: "imageLink",
	4: "birthDate",
	5: "telephone",
}

// Decode decodes ProfileUpdate from json.
func (s *ProfileUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProfileUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "firstName":
			if err := func() error {
				s.FirstName.Reset()
				if err := s.FirstName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstName\"")
			}
		case "lastName":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastName\"")
			}
		case "imageLink":
			if err := func() error {
				s.ImageLink.Reset()
				if err := s.ImageLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageLink\"")
			}
		case "birthDate":
			if err := func() error {
				s.BirthDate.Reset()
				if err := s.BirthDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthDate\"")
			}
		case "telephone":
			if err := func() error {
				s.Telephone.Reset()
				if err := s.Telephone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telephone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProfileUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProfileUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProfileUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RootFlag as json.
func (s RootFlag) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes RootFlag from json.
func (s *RootFlag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RootFlag to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RootFlag(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RootFlag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RootFlag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TelephoneString as json.
func (s TelephoneString) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TelephoneString from json.
func (s *TelephoneString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelephoneString to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TelephoneString(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TelephoneString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelephoneString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserId as json.
func (s UserId) Encode(e *jx.Encoder) {
	unwrapped := uuid.UUID(s)

	json.EncodeUUID(e, unwrapped)
}

// Decode decodes UserId from json.
func (s *UserId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserId to nil")
	}
	var unwrapped uuid.UUID
	if err := func() error {
		v, err := json.DecodeUUID(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UserId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
